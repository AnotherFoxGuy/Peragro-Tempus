#!/bin/bash
if [ "$1" = "" ]; then
  echo "Usage networkcodegenerator.sh [msgs_???.xml]"
  echo ""
  echo "the script will generate the files ???messages.cpp and ???messages.h based on msgs_???.xml"
  echo "and of course, replace ??? with a suitable name (examples: door, book, user)"
  echo ""
  echo "you can also specify -auto [overwrite] as filename to generate all messages automatically (assumes you are either in PT/scripts/ or PT/)"
  exit
fi

start="/*
    Copyright (C) 2005 Development Team of Peragro Tempus

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

//  !! This file was automatically generated by networkcodegenerator.sh    !!
//  !! Do not change this file since all changes will be overwritten later !!
//  !! Instead please change the source files here: peragro/data/generate  !!
"

if [ "$1" = "-auto" ]; then
  if [ "$(echo -n "$0" | sed -e "s/\/.*//;")" != "scripts" ]; then cd ..; fi
  cd src/common/network
  files="$(ls -1 ../../../data/generate/network | sed -n -e "/msgs_.*\.xml\$/p" | sed -e "/^msgs_connection\.xml\$/d")"
  if [ "$2" != "overwrite" ]; then
# Old check, the new one works more like jam (overwrite is like jam -a then)
#    overwritecheck1="if [ ! -e \"\$(echo \"&\" | sed -e \"s\\/^.*_\\/\\/;s\\/\\\.xml\\\$\\/\\/;\")messages.cpp\" ]; then "
#    overwritecheck2="; else echo \"Skipping & since it has already been generated.\"; fi"
    overwritecheck1="overwrite=\"\"; \
                     if [ \"\$(stat \$(echo \"&\" | sed -e \"s\\/^.*_\\/\\/;s\\/\\\.xml\\\$\\/\\/;\")messages.cpp -c %Y)\" -lt \"\$(stat ..\\/..\\/..\\/data\\/generate\\/network\\/& -c %Y)\" ]; then overwrite=\"yes\"; fi; \
                     if [ ! -e \"\$(echo \"&\" | sed -e \"s\\/^.*_\\/\\/;s\\/\\\.xml\\\$\\/\\/;\")messages.cpp\" ]; then overwrite=\"yes\"; fi; \
                     if [ \"\$overwrite\" = \"yes\" ]; then "
    overwritecheck2="; else echo \"Skipping & since it has already been generated and hasn't changed since then.\"; fi"
  fi
  files="$(echo "$files" | sed -e "s/^.*\$/${overwritecheck1}echo \"Parsing &...\"\n\.\.\/\.\.\/\.\.\/scripts\/networkcodegenerator.sh \.\.\/\.\.\/\.\.\/data\/generate\/network\/&${overwritecheck2}/")"
  eval "$files"
  # Generate nwtypes.h
  messagetypes="$(cat ../../../data/generate/network/netmessage.xml | grep "<type " | sed -e "s/^.*name=\"/    /;s/\">/,/;y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/;")"
  while [ "$(echo "$messagetypes" | sed -n -e "/[^0-9],/p")" != "" ]; do
    line="$(echo -n "$messagetypes" | sed -n -e "/[^0-9],/=" | head -n 1 | head -c -1)"
    messagetypes="$(echo -n "$messagetypes" | sed -e "$line s/,/=$(($line-1)),/;")"
  done
  messagetypes="$(echo -n "$messagetypes" | head -c -1)"
  echo "$start
#ifndef NWTYPES_H
#define NWTYPES_H

#define MSG_HANDLER_COUNT $(echo "$messagetypes" | wc -l)

namespace MESSAGES
{
  enum HANDLERS
  {
$messagetypes
  };
}

#endif // NWTYPES_H" > nwtypes.h
  exit
fi

name="$(echo -n "$1" | sed -e "s/^.*_//;s/\.xml\$//;")"
nameuc="$(echo -n "$name" | sed -e "y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/;")"
nameucfirst="$(echo -n "$nameuc" | head -c 1; echo -n "$name" | sed -e "s/.//;")"

data="$(cat "$1" | sed -e "s/\r//;s/>[ 	]*</>\n</;")"

out_cpp="$start
#include \"common/network/${name}messages.h\"
#include \"deserialiser.h\"
#include \"serialiser.h\""
out_h="$start
#ifndef ${nameuc}MESSAGES_H
#define ${nameuc}MESSAGES_H

#include \"netmessage.h\"

namespace ${nameuc}
{
  enum MESSAGES
  {"

count=1
while [ "$data" != "" ]; do
line="$(echo -n "$data" | sed -n -e "1p")"
data="$(echo -n "$data" | sed -e "1d")"
if [ "$(echo "$line" | grep "</message>")" != "" ]; then
messages[$count]="$message"
count=$(($count+1))
message=""
fi
message="$message
$line"
done
number_of_messages="$count"

count=1
messageindex=""
out_h_classes="  };
}
"
while [ "$count" -lt "$number_of_messages" ]; do
listconst=""
listdestroy=""
message="${messages[$count]}"
messagename="$(echo -n "$message" | sed -n -e "/<message /{s/.* name=[\"']*//;s/[^a-zA-Z]*\$//;p;}")"
messagename_uc="$(echo -n "$messagename" | sed -e "y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/;")"
messageindex="${messageindex}    ${messagename_uc}=$(($count-1))"
if [ "$(($count+1))" -lt "$number_of_messages" ]; then messageindex="${messageindex},
"; fi
cpp1="void ${messagename}Message::serialise(ByteStream* bs)
{
  Serialiser serial(bs);
  serial.setInt8(type);
  serial.setInt8(id);"
cpp2="void ${messagename}Message::deserialise(ByteStream* bs)
{
  Deserialiser serial(bs);
  type = serial.getInt8();
  id = serial.getInt8();"
out_h_classes1="class ${messagename}Message : public NetMessage
{"
out_h_classes2="  void serialise(ByteStream* bs);
  void deserialise(ByteStream* bs);"

cpplist="" # Prevent contamination from previous messages (although they would have to be incorrect then.. missing </list>)
listpad=""

while [ "$message" != "" ]; do
line="$(echo -n "$message" | sed -n -e "1p")"
message="$(echo -n "$message" | sed -e "1d")"
vartype="$(echo "$line" | sed -e "s/[^<]*<//;s/[> ].*//;")"
varname_case="$(echo "$line" | sed -e "s/[^>]*>//;s/<[^<]*//;")"
varname="$(echo "$varname_case" | sed -e "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/;")"

# Big group of datatypes..
if [ "$vartype" = "string" ]; then
cpp1="$cpp1
  ${listpad}serial.setString(${cpplist}${varname});"
cpp2="$cpp2
  ${listpad}${cpplist}${varname} = serial.getString();"
out_h_classes1="$out_h_classes1
  ${listpad}ptString ${varname};"
out_h_classes2="$out_h_classes2

  ptString get${varname_case}(${hlist1}) { return ${cpplist}${varname}; }
  void set${varname_case}(${hlist2}ptString x) { ${cpplist}${varname} = x; }"
fi
if [ "$vartype" = "text" ]; then
cpp1="$cpp1
  ${listpad}serial.setString(${cpplist}${varname});"
cpp2="$cpp2
  ${listpad}serial.getString(${cpplist}${varname});"
out_h_classes1="$out_h_classes1
  ${listpad}const char* ${varname};"
out_h_classes2="$out_h_classes2

  const char* get${varname_case}(${hlist1}) { return ${cpplist}${varname}; }
  void set${varname_case}(${hlist2}const char* x) { ${cpplist}${varname} = x; }"
fi
if [ "$vartype" = "uint32" ]; then
cpp1="$cpp1
  ${listpad}serial.setInt32(${cpplist}${varname});"
cpp2="$cpp2
  ${listpad}${cpplist}${varname} = (unsigned int) serial.getInt32();"
out_h_classes1="$out_h_classes1
  ${listpad}unsigned int ${varname};"
out_h_classes2="$out_h_classes2

  unsigned int get${varname_case}(${hlist1}) { return ${cpplist}${varname}; }
  void set${varname_case}(${hlist2}unsigned int x) { ${cpplist}${varname} = x; }"
fi
if [ "$vartype" = "uint16" ]; then
cpp1="$cpp1
  ${listpad}serial.setInt16(${cpplist}${varname});"
cpp2="$cpp2
  ${listpad}${cpplist}${varname} = (unsigned short) serial.getInt16();"
out_h_classes1="$out_h_classes1
  ${listpad}unsigned short ${varname};"
out_h_classes2="$out_h_classes2

  unsigned short get${varname_case}(${hlist1}) { return ${cpplist}${varname}; }
  void set${varname_case}(${hlist2}unsigned short x) { ${cpplist}${varname} = x; }"
fi
if [ "$vartype" = "uint8" ]; then
cpp1="$cpp1
  ${listpad}serial.setInt8(${cpplist}${varname});"
cpp2="$cpp2
  ${listpad}${cpplist}${varname} = (unsigned char) serial.getInt8();"
out_h_classes1="$out_h_classes1
  ${listpad}unsigned char ${varname};"
out_h_classes2="$out_h_classes2

  unsigned char get${varname_case}(${hlist1}) { return ${cpplist}${varname}; }
  void set${varname_case}(${hlist2}unsigned char x) { ${cpplist}${varname} = x; }"
fi
if [ "$vartype" = "bool" ]; then
cpp1="$cpp1
  ${listpad}serial.setInt8(${cpplist}${varname}?1:0);"
cpp2="$cpp2
  ${listpad}${cpplist}${varname} = serial.getInt8() != 0;"
out_h_classes1="$out_h_classes1
  ${listpad}bool ${varname};"
out_h_classes2="$out_h_classes2

  bool get${varname_case}(${hlist1}) { return ${cpplist}${varname}; }
  void set${varname_case}(${hlist2}bool x) { ${cpplist}${varname} = x; }"
fi
if [ "$vartype" = "float" ]; then
cpp1="$cpp1
  ${listpad}serial.setFloat(${cpplist}${varname});"
cpp2="$cpp2
  ${listpad}${cpplist}${varname} = serial.getFloat();"
out_h_classes1="$out_h_classes1
  ${listpad}float ${varname};"
out_h_classes2="$out_h_classes2

  float get${varname_case}(${hlist1}) { return ${cpplist}${varname}; }
  void set${varname_case}(${hlist2}float x) { ${cpplist}${varname} = x; }"
fi
if [ "$vartype" = "colour24" ]; then
cpp1="$cpp1
  ${listpad}serial.setInt8(${cpplist}${varname}[0]);
  ${listpad}serial.setInt8(${cpplist}${varname}[1]);
  ${listpad}serial.setInt8(${cpplist}${varname}[2]);"
cpp2="$cpp2
  ${listpad}${cpplist}${varname}[0] = (unsigned char) serial.getInt8();
  ${listpad}${cpplist}${varname}[1] = (unsigned char) serial.getInt8();
  ${listpad}${cpplist}${varname}[2] = (unsigned char) serial.getInt8();"
out_h_classes1="$out_h_classes1
  ${listpad}unsigned char ${varname}[3];"
out_h_classes2="$out_h_classes2

  unsigned char* get${varname_case}(${hlist1}) { return ${cpplist}${varname}; }
  void set${varname_case}(${hlist2}unsigned char r, unsigned char g, unsigned char b)
  {
    ${cpplist}${varname}[0] = r;
    ${cpplist}${varname}[1] = g;
    ${cpplist}${varname}[2] = b;
  }
  void set${varname_case}(${hlist2}const unsigned char* x)
  {
    set${varname_case}(${hlist3}x[0], x[1], x[2]);
  }"
fi
if [ "$vartype" = "vector3f" ]; then
cpp1="$cpp1
  ${listpad}serial.setFloat(${cpplist}${varname}[0]);
  ${listpad}serial.setFloat(${cpplist}${varname}[1]);
  ${listpad}serial.setFloat(${cpplist}${varname}[2]);"
cpp2="$cpp2
  ${listpad}${cpplist}${varname}[0] = serial.getFloat();
  ${listpad}${cpplist}${varname}[1] = serial.getFloat();
  ${listpad}${cpplist}${varname}[2] = serial.getFloat();"
out_h_classes1="$out_h_classes1
  ${listpad}float ${varname}[3];"
out_h_classes2="$out_h_classes2

  float* get${varname_case}(${hlist1}) { return ${cpplist}${varname}; }
  void set${varname_case}(${hlist2}float x, float y, float z)
  {
    ${cpplist}${varname}[0] = x;
    ${cpplist}${varname}[1] = y;
    ${cpplist}${varname}[2] = z;
  }
  void set${varname_case}(${hlist2}const float* x)
  {
    set${varname_case}(${hlist3}x[0], x[1], x[2]);
  }"
fi

# Those pesky lists..
if [ "$vartype" = "list" ]; then
listname="$(echo -n "$line" | sed -e "s/.* name=[\"']*//;s/[^a-zA-Z]*\$//;")"
listname_lc="$(echo -n "$listname" | sed -e "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/;")"
cpp1="$cpp1
  serial.setInt8(${listname_lc}count);
  for ( size_t i = 0; i < ${listname_lc}count ; i++ )
  {"
cpp2="$cpp2
  ${listname_lc}count = (unsigned char) serial.getInt8();
  set${listname}Count(${listname_lc}count);
  for ( size_t i = 0; i < ${listname_lc}count ; i++ )
  {"
out_h_classes1="$out_h_classes1
  class List${listname}
  {
  public:"
out_h_classes2="$out_h_classes2

  unsigned char get${listname}Count() { return ${listname_lc}count; }
  void set${listname}Count(unsigned char ic)
  {
    ${listname_lc}count = ic;
    delete [] ${listname_lc};
    ${listname_lc} = new List${listname}[ic];
  }

  // --- begin List${listname} Getter and Setter ---"
cpplist="${listname_lc}[i]."
hlist1="size_t i"
hlist2="size_t i, "
hlist3="i, "
listpad="  "
listconst="$listconst
    ${listname_lc} = 0;"
listdestroy="$listdestroy
    delete [] ${listname_lc};"
fi
if [ "$vartype" = "/list" ]; then
cpp1="$cpp1
  };"
cpp2="$cpp2
  };"
out_h_classes1="$out_h_classes1
  };

  unsigned char ${listname_lc}count;
  List${listname}* ${listname_lc};" # This is kinda bad practice, but </list> contains no name of its list
out_h_classes2="$out_h_classes2

  // --- end List${listname} Getter and Setter ---"
cpplist=""
hlist1=""
hlist2=""
hlist3=""
listpad=""
fi

done
out_cpp="$out_cpp

$cpp1
}

$cpp2
}"
out_h_classes="$out_h_classes
$out_h_classes1

public:
  ${messagename}Message() : NetMessage(MESSAGES::${nameuc},${nameuc}::${messagename_uc})
  {$listconst
  }

  ~${messagename}Message()
  {$listdestroy
  }

$out_h_classes2

};
"
count=$(($count+1))
done
out_h="$out_h
$messageindex
$out_h_classes
#endif // ${nameuc}MESSAGES_H"

echo "$out_cpp" > ${name}messages.cpp
echo "$out_h" > ${name}messages.h

peer_="$(cat "$(echo -n "$1" | sed -e "s/[^\/]*\$/peer_client.xml/")" | sed -n -e "/<receive>/,/<\/receive>/{/^[ \t]*<message.* type=\"${nameucfirst}\"/{s/.* name=\"//;s/\".*//;p;};}" | sed -e "/^[ \t]*\$/d")"
peer="$peer_"

echo "$start
#ifndef ${nameuc}HANDLER_H
#define ${nameuc}HANDLER_H

#include \"common/network/nwtypes.h\"

#include \"common/network/${name}messages.h\"

class ${nameucfirst}Handler : public MessageHandler
{
public:
  ${nameucfirst}Handler()
  {
  }

  char getType() { return MESSAGES::${nameuc}; }

  void handle(GenericMessage* msg)
  {
    char type = msg->getMsgType();
    if (type != MESSAGES::${nameuc}) assert(\"wrong message type\");" > ../../client/network/${name}handler.h
if [ "$peer" != "" ]; then
echo "    char id = msg->getMsgId();
" >> ../../client/network/${name}handler.h
msg="$(echo -n "$peer" | sed -n -e "1p")"
peer="$(echo -n "$peer" | sed -e "1d")"
msguc="$(echo -n "$msg" | sed -e "y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/;")"
echo "    if (id == ${nameuc}::${msguc}) handle${msg}(msg);" >> ../../client/network/${name}handler.h
while [ "$peer" != "" ]; do
msg="$(echo -n "$peer" | sed -n -e "1p")"
peer="$(echo -n "$peer" | sed -e "1d")"
msguc="$(echo -n "$msg" | sed -e "y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/;")"
echo "    else if (id == ${nameuc}::${msguc}) handle${msg}(msg);" >> ../../client/network/${name}handler.h
done
fi
echo "  }
" >> ../../client/network/${name}handler.h
peer="$peer_"
while [ "$peer" != "" ]; do
msg="$(echo -n "$peer" | sed -n -e "1p")"
peer="$(echo -n "$peer" | sed -e "1d")"
echo "  void handle${msg}(GenericMessage* msg);" >> ../../client/network/${name}handler.h
done
echo "};

#endif // ${nameuc}HANDLER_H" >> ../../client/network/${name}handler.h

peer_="$(cat "$(echo -n "$1" | sed -e "s/[^\/]*\$/peer_server.xml/")" | sed -n -e "/<receive>/,/<\/receive>/{/^[ \t]*<message.* type=\"${nameucfirst}\"/{s/.* name=\"//;s/\".*//;p;};}")"
peer="$peer_"

echo "$start
#ifndef ${nameuc}HANDLER_H
#define ${nameuc}HANDLER_H

#include \"common/network/nwtypes.h\"

#include \"common/network/${name}messages.h\"

class ${nameucfirst}Handler : public MessageHandler
{
public:
  ${nameucfirst}Handler()
  {
  }

  char getType() { return MESSAGES::${nameuc}; }

  void handle(GenericMessage* msg)
  {
    char type = msg->getMsgType();
    if (type != MESSAGES::${nameuc}) assert(\"wrong message type\");" > ../../server/network/${name}handler.h
if [ "$peer" != "" ]; then
echo "    char id = msg->getMsgId();
" >> ../../server/network/${name}handler.h
msg="$(echo -n "$peer" | sed -n -e "1p")"
peer="$(echo -n "$peer" | sed -e "1d")"
msguc="$(echo -n "$msg" | sed -e "y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/;")"
echo "    if (id == ${nameuc}::${msguc}) handle${msg}(msg);" >> ../../server/network/${name}handler.h
while [ "$peer" != "" ]; do
msg="$(echo -n "$peer" | sed -n -e "1p")"
peer="$(echo -n "$peer" | sed -e "1d")"
msguc="$(echo -n "$msg" | sed -e "y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/;")"
echo "    else if (id == ${nameuc}::${msguc}) handle${msg}(msg);" >> ../../server/network/${name}handler.h
done
fi
echo "  }
" >> ../../server/network/${name}handler.h
peer="$peer_"
while [ "$peer" != "" ]; do
msg="$(echo -n "$peer" | sed -n -e "1p")"
peer="$(echo -n "$peer" | sed -e "1d")"
echo "  void handle${msg}(GenericMessage* msg);" >> ../../server/network/${name}handler.h
done
echo "};

#endif // ${nameuc}HANDLER_H" >> ../../server/network/${name}handler.h
