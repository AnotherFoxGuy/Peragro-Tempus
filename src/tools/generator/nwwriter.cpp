/*
    Copyright (C) 2007 Development Team of Peragro Tempus

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include "nwwriter.h"

#include "network.h"

#include <algorithm>
#include <iostream>

/// \todo: It would be better to use a template rather than hardcode everything.

namespace
{
  const char* nwParamTypeName[][2] = {
    {"ptString", "String"},
    {"const char*", "String"},
    {"WFMath::Point<3>", "Vector3_special_case"},
    {"bool", "Int8"},
    {"unsigned char", "Int8"},
    {"unsigned short", "Int16"},
    {"unsigned int", "Int32"},
    {"char", "Int8"},
    {"short", "Int16"},
    {"int", "Int32"},
    {"float", "Float"},
    {"PT::Colour24", "Colour24_special_case"},
    {"List_special_case", "List_special_case"}
  };
}

nwWriter::nwWriter(nwNetwork* nw) : nw(nw)
{
}

std::string nwWriter::toConst(std::string str)
{
  std::transform(str.begin(), str.end(), str.begin(), toupper);
  return str;
}

std::string nwWriter::toVariable(std::string str)
{
  std::transform(str.begin(), str.end(), str.begin(), tolower);
  //str.insert(0, "m_");
  return str;
}

std::string nwWriter::toFunction(std::string str)
{
  str[0] = (char) tolower(str[0]);
  return str;
}

void nwWriter::writeLicenceHeader(std::ofstream& out)
{
  out <<
    "/*\n"
    "    Copyright (C) 2008 Development Team of Peragro Tempus\n\n"

    "    This program is free software; you can redistribute it and/or modify\n"
    "    it under the terms of the GNU General Public License as published by\n"
    "    the Free Software Foundation; either version 2 of the License, or\n"
    "    (at your option) any later version.\n\n"

    "    This program is distributed in the hope that it will be useful,\n"
    "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
    "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
    "    GNU General Public License for more details.\n\n"

    "    You should have received a copy of the GNU General Public License\n"
    "    along with this program; if not, write to the Free Software\n"
    "    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n"
    "*/\n\n";

  out <<
    "//  !! This file was automatically generated by a network code generator   !!\n"
    "//  !! Do not change this file since all changes will be overwritten later !!\n"
    "//  !! Instead please change the source files here: peragro/data/generate  !!\n\n";
}

void nwWriter::writeNetwork(std::ofstream& out)
{
  writeLicenceHeader(out);

  out << "#ifndef NWTYPES_H\n";
  out << "#define NWTYPES_H\n";

  out << "\n"
         "#define MSG_NET_VERSION " << nw->netId << "\n"
         "\n";

  size_t i = 0;
  for (i = 0; i < nw->peers.size(); i++)
  {
    out << "#define MSG_" << toConst(nw->peers[i]->name)
        << "_PEER_VERSION " << nw->peers[i]->netId << "\n";
  }

  out << "\n"
         "#define MSG_HANDLER_COUNT " << nw->types.size() << "\n"
         "\n"
         "namespace MESSAGES\n"
         "{\n"
         "  enum HANDLERS\n"
         "  {\n";

  for (i = 0; i < nw->types.size()-1; i++)
  {
    out << "    " << toConst(nw->types[i]->name) <<
           " = " << nw->types[i]->id << ",\n";
  }

  out << "    " << toConst(nw->types[i]->name) <<
         " = " << nw->types[i]->id << "\n";

  out << "  };\n"
         "}\n"
         "\n";

  out << "#endif // NWTYPES_H\n";
}

void nwWriter::writeParamDeclaration(std::ofstream& out, nwParams* param)
{
  switch (param->type)
  {
    case nwParamType::LIST:
    {
      out << "  class List" << param->name << "\n"
          << "  {\n"
          << "  public:\n";

      for (size_t i = 0; i < param->params.size(); ++i)
      {
        writeParamListDefinition(out, param->params[i]);
      }

      out << "  };\n\n";
      out << "  unsigned int " << toVariable(param->name) << "count;\n";
      out << "  List" << param->name << "* " << toVariable(param->name) << ";\n\n";
      break;
    }
    default:
    {
      const char* const typeName = nwParamTypeName[param->type][0];
      out << "  " << typeName << " " << toVariable(param->name) << ";\n";
    }
  }
}

void nwWriter::writeParamSerialisation(std::ofstream& out, nwParams* param)
{
  switch (param->type)
  {
    case nwParamType::COLOUR24:
    {
      out <<  "  serial.setInt8(" << toVariable(param->name) << ".red);\n";
      out <<  "  serial.setInt8(" << toVariable(param->name) << ".green);\n";
      out <<  "  serial.setInt8(" << toVariable(param->name) << ".blue);\n";
      break;
    }
    case nwParamType::VECTOR3F:
    {
      out <<  "  serial.setFloat(" << toVariable(param->name) << ".x());\n";
      out <<  "  serial.setFloat(" << toVariable(param->name) << ".y());\n";
      out <<  "  serial.setFloat(" << toVariable(param->name) << ".z());\n";
      break;
    }
    case nwParamType::LIST:
    {
      out <<  "  serial.setInt24(" << toVariable(param->name) << "count);\n"
          <<  "  for ( size_t i = 0; i < " << toVariable(param->name) << "count ; i++ )\n"
          <<  "  {\n";

      for (size_t i = 0; i < param->params.size(); ++i)
      {
        writeParamListSerialisation(out, param->name, param->params[i]);
      }

      out <<  "  };\n\n";
      break;
    }
    default:
    {
      const char* const typeFunctionName = nwParamTypeName[param->type][1];
      out << "  serial.set" << typeFunctionName << "(" << toVariable(param->name) << ");\n";
    }
  }
}

void nwWriter::writeParamDeserialisation(std::ofstream& out, nwParams* param)
{
  switch (param->type)
  {
    case nwParamType::TEXT:
    {
      out <<  "  serial.getString(" << toVariable(param->name) << ");\n";
      break;
    }
    case nwParamType::COLOUR24:
    {
      out << "  " << toVariable(param->name) << ".red = static_cast<PT::Colour24::ColourType>(serial.getInt8());\n";
      out << "  " << toVariable(param->name) << ".green = static_cast<PT::Colour24::ColourType>(serial.getInt8());\n";
      out << "  " << toVariable(param->name) << ".blue = static_cast<PT::Colour24::ColourType>(serial.getInt8());\n";
      break;
    }
    case nwParamType::VECTOR3F:
    {
      out << "  " << toVariable(param->name) << ".x() = serial.getFloat();\n";
      out << "  " << toVariable(param->name) << ".y() = serial.getFloat();\n";
      out << "  " << toVariable(param->name) << ".z() = serial.getFloat();\n";
      break;
    }
    case nwParamType::LIST:
    {
      out << "  " << toVariable(param->name) << "count = static_cast<unsigned int>(serial.getInt24());\n"
          << "  set" << param->name << "Count(" << toVariable(param->name) << "count);\n"
          << "  for (size_t i = 0; i < " << toVariable(param->name) << "count ; ++i)\n"
          << "  {\n";

      for (size_t i = 0; i < param->params.size(); ++i)
      {
        writeParamListDeserialisation(out, param->name, param->params[i]);
      }

      out <<  "  };\n\n";
      break;
    }
    default:
    {
      const char* const typeName = nwParamTypeName[param->type][0];
      const char* const typeFunctionName = nwParamTypeName[param->type][1];
      out << "  " << toVariable(param->name) << " = static_cast<" << typeName
          << ">(serial.get" << typeFunctionName << "());\n";
    }
  }
}

void nwWriter::writeParamGetterSetter(std::ofstream& out, nwParams* param)
{
  const char* const typeName = nwParamTypeName[param->type][0];
  switch (param->type)
  {
    case nwParamType::VECTOR3F:
    {
      out << "  WFMath::Point<3> get" << param->name << "() { return "
          << toVariable(param->name) << "; }\n"
          << "  void set" << param->name << "(const WFMath::Point<3>& x)\n"
          << "  {\n"
          << "    " << toVariable(param->name) << " = x;\n"
          << "  }\n"
          << "  void set" << param->name << "(float x, float y, float z)\n"
          << "  {\n"
          << "    " << toVariable(param->name) << "[0] = x;\n"
          << "    " << toVariable(param->name) << "[1] = y;\n"
          << "    " << toVariable(param->name) << "[2] = z;\n"
          << "  }\n\n";
      break;
    }
    case nwParamType::LIST:
    {
      out << "  unsigned char get" << param->name << "Count() const { return "
          << toVariable(param->name) << "count; }\n"
          << "  void set" << param->name << "Count(unsigned char ic)\n"
          << "  {\n"
          << "    " << toVariable(param->name) << "count = ic;\n"
          << "    delete [] " << toVariable(param->name) << ";\n"
          << "    " << toVariable(param->name) << " = new List" << param->name
          << "[ic];\n"
          << "  }\n\n";

      out << "  // --- begin List" << param->name << " Getter and Setter ---\n\n";

      for (size_t i = 0; i < param->params.size(); ++i)
      {
        writeParamListGetterSetter(out, param->name, param->params[i]);
      }
      out << "  // --- end List" << param->name << " Getter and Setter ---\n\n";
      break;
    }
    default:
    {
      out << "  " << typeName << " get" << param->name << "() const { return "
        << toVariable(param->name) << "; }\n"
        << "  void set"<< param->name << "(" << typeName << " x) { "
        << toVariable(param->name) << " = x; }\n\n";
    }
  }
}

void nwWriter::writeParamListDefinition(std::ofstream& out, nwParams* param)
{
  switch (param->type)
  {
    case nwParamType::LIST:
    {
      std::cerr << "Error! Nested Lists are not yet supported!";
      break;
    }
    default:
    {
      const char* const typeName = nwParamTypeName[param->type][0];
      out << "    " << typeName << " " << toVariable(param->name) << ";\n";
    }
  }
}

void nwWriter::writeParamListSerialisation(std::ofstream& out, std::string listname, nwParams* param)
{
  switch (param->type)
  {
    case nwParamType::COLOUR24:
    {
      out << "    serial.setInt8(" << toVariable(listname) << "[i]." << toVariable(param->name) << ".red);\n";
      out << "    serial.setInt8(" << toVariable(listname) << "[i]." << toVariable(param->name) << ".green);\n";
      out << "    serial.setInt8(" << toVariable(listname) << "[i]." << toVariable(param->name) << ".blue);\n";
      break;
    }
    case nwParamType::VECTOR3F:
    {
      out << "    serial.setFloat(" << toVariable(listname) << "[i]." << toVariable(param->name) << ".x);\n";
      out << "    serial.setFloat(" << toVariable(listname) << "[i]." << toVariable(param->name) << ".y);\n";
      out << "    serial.setFloat(" << toVariable(listname) << "[i]." << toVariable(param->name) << ".z);\n";
      break;
    }
    case nwParamType::LIST:
    {
      std::cerr << "Error! Nested Lists are not yet supported!";
      break;
    }
    default:
    {
      const char* const typeFunctionName = nwParamTypeName[param->type][1];
      out << "    serial.set" << typeFunctionName << "(" << toVariable(listname) << "[i]."
          << toVariable(param->name) << ");\n";
    }
  }
}

void nwWriter::writeParamListDeserialisation(std::ofstream& out, std::string listname, nwParams* param)
{
  switch (param->type)
  {
    case nwParamType::TEXT:
    {
      out << "    serial.getString(" << toVariable(listname) << "[i]." << toVariable(param->name) << ");\n";
      break;
    }
    case nwParamType::COLOUR24:
    {
      out << "    " << toVariable(listname) << "[i]." << toVariable(param->name)
        << ".red = static_cast<unsigned char>(serial.getInt8());\n";
      out << "    " << toVariable(listname) << "[i]." << toVariable(param->name)
        << ".green = static_cast<unsigned char>(serial.getInt8());\n";
      out << "    " << toVariable(listname) << "[i]." << toVariable(param->name)
        << ".blue = static_cast<unsigned char>(serial.getInt8());\n";
      break;
    }
    case nwParamType::VECTOR3F:
    {
      out << "    " << toVariable(listname) << "[i]." << toVariable(param->name) << ".x = serial.getFloat();\n";
      out << "    " << toVariable(listname) << "[i]." << toVariable(param->name) << ".y = serial.getFloat();\n";
      out << "    " << toVariable(listname) << "[i]." << toVariable(param->name) << ".z = serial.getFloat();\n";
      break;
    }
    case nwParamType::LIST:
    {
      std::cerr << "Error! Nested Lists are not yet supported!";
      break;
    }
    default:
    {
      const char* const typeName = nwParamTypeName[param->type][0];
      const char* const typeFunctionName = nwParamTypeName[param->type][1];
      out << "    " << toVariable(listname) << "[i]." << toVariable(param->name)
          << " = static_cast<" << typeName << ">(serial.get" << typeFunctionName << "());\n";
    }
  }
}

void nwWriter::writeParamListGetterSetter(std::ofstream& out, std::string listname, nwParams* param)
{
  switch (param->type)
  {
    case nwParamType::VECTOR3F:
    {
      out << "  WFMath::Point<3> get" << param->name << "(size_t i) { return "
          << toVariable(listname) << "[i]." << toVariable(param->name) << "; }\n"
          << "  void set" << param->name << "(size_t i, const WFMath::Point<3>& x)\n"
          << "  {\n"
          << "    " << toVariable(listname) << "[i]." << toVariable(param->name) << " = x;\n"
          << "  }\n"
          << "  void set" << param->name << "(size_t i, float x, float y, float z)\n"
          << "  {\n"
          << "    " << toVariable(listname) << "[i]." << toVariable(param->name) << ".x = x;\n"
          << "    " << toVariable(listname) << "[i]." << toVariable(param->name) << ".y = y;\n"
          << "    " << toVariable(listname) << "[i]." << toVariable(param->name) << ".z = z;\n"
          << "  }\n\n";
      break;
    }
    case nwParamType::LIST:
    {
      std::cerr << "Error! Nested Lists are not yet supported!";
      break;
    }
    default:
    {
      const char* const typeName = nwParamTypeName[param->type][0];
      out << "  " << typeName << " get" << param->name << "(size_t i) { return "
          << toVariable(listname) << "[i]." << toVariable(param->name) << "; }\n"
          << "  void set" << param->name << "(size_t i, " << typeName << " x) { "
          << toVariable(listname) << "[i]." << toVariable(param->name) << " = x; }\n\n";
    }
  }
}

void nwWriter::writeTypeHead(std::ofstream& out, nwType* type)
{
  writeLicenceHeader(out);

  out << "#ifndef " << toConst(type->name) << "MESSAGES_H\n";
  out << "#define " << toConst(type->name) << "MESSAGES_H\n\n";

  out << "#include \"netmessage.h\"\n\n";

  out << "namespace " << toConst(type->name) << "\n"
         "{\n"
         "  enum MESSAGES\n"
         "  {\n";

  size_t i = 0;
  for (i = 0; i < type->msgs.size()-1; ++i)
  {
    out << "    " << toConst(type->msgs[i]->name) <<
           " = " << type->msgs[i]->id << ",\n";
  }

  out << "    " << toConst(type->msgs[i]->name) <<
         " = " << type->msgs[i]->id << "\n";

  out << "  };\n"
         "}\n\n";

  for (i = 0; i < type->msgs.size(); ++i)
  {
    nwMessage* msg = type->msgs[i];

    out << "class " << msg->name << "Message : public NetMessage\n"
           "{\n";

    for (size_t j = 0; j < msg->params.size(); ++j)
    {
      nwParams* param = msg->params[j];
      writeParamDeclaration(out, param);
    }

    out << "\n"
           "public:\n"
           "  " << msg->name.c_str ()<< "Message() : NetMessage(MESSAGES::" <<
           toConst(type->name) << "," << toConst(type->name) <<
           "::" << toConst(msg->name) << ")\n"
           "  {\n";
    for (size_t j = 0; j < msg->params.size(); ++j)
    {
      nwParams* param = msg->params[j];
      if (param->type == nwParamType::LIST)
      {
        out << "    " << toVariable(param->name) << " = 0;\n";
      }
    }

    out << "  }\n\n"
           "  ~" << msg->name.c_str ()<< "Message()\n" <<
           "  {\n";

    for (size_t j = 0; j < msg->params.size(); j++)
    {
      nwParams* param = msg->params[j];
      if (param->type == nwParamType::LIST)
      {
        out << "    delete [] " << toVariable(param->name) << ";\n";
      }
    }

    out << "  }\n\n"
           "  bool serialise(ByteStream* bs);\n"
           "  void deserialise(ByteStream* bs);\n\n";

    for (size_t j = 0; j < msg->params.size(); j++)
    {
      nwParams* param = msg->params[j];
      writeParamGetterSetter(out, param);
    }

    out << "};\n\n";
  }

  out << "#endif // "<< toConst(type->name) <<"MESSAGES_H\n";
}

void nwWriter::writeTypeImpl(std::ofstream& out, nwType* type)
{
  writeLicenceHeader(out);

  out << "#include \"common/network/" << toVariable(type->name) << "messages.h\"\n"
      << "#include \"deserialiser.h\"\n"
      << "#include \"serialiser.h\"\n\n";

  for (size_t i = 0; i < type->msgs.size(); i++)
  {
    nwMessage* msg = type->msgs[i];

    out << "bool " << msg->name.c_str ()<< "Message::serialise(ByteStream* bs)\n"
           "{\n"
           "  Serialiser serial(bs);\n"
           "  serial.setInt8(type);\n"
           "  serial.setInt8(id);\n";

    for (size_t j = 0; j < msg->params.size(); j++)
    {
      nwParams* param = msg->params[j];
      writeParamSerialisation(out, param);
    }
    out << "  return serial.isValid();\n"
           "}\n"
           "\n"
           "void " << msg->name.c_str ()<< "Message::deserialise(ByteStream* bs)\n"
           "{\n"
           "  Deserialiser serial(bs);\n"
           "  type = serial.getInt8();\n"
           "  id = serial.getInt8();\n";

    for (size_t j = 0; j < msg->params.size(); j++)
    {
      nwParams* param = msg->params[j];
      writeParamDeserialisation(out, param);
    }

    out << "}\n\n";
  }
}

void nwWriter::writeHandler(std::ofstream& out, nwPeer* peer, nwType* type)
{
  writeLicenceHeader(out);

  out << "#ifndef " << toConst(type->name) << "HANDLER_H\n";
  out << "#define " << toConst(type->name) << "HANDLER_H\n\n";

  out << "#include \"common/network/nwtypes.h\"\n";
  out << "#include \"common/network/messagehandler.h\"\n\n";
  out << "#include \"common/network/" << toVariable(type->name) << "messages.h\"\n\n";

  //out << "class " << peer->name << ";\n\n";

  out << "class " << type->name << "Handler : public MessageHandler\n"
      << "{\n"
      //<< "private:\n"
      //<< "  " << peer->name << "* " << toVariable(peer->name) << ";\n\n"

      << "public:\n"
      << "  " << type->name << "Handler(" /* << peer->name << "* "
      << toVariable(peer->name) */ << ")\n"
      //<< "  : " << toVariable(peer->name) << "(" << toVariable(peer->name) << ")\n"
      << "  {\n"
      << "  }\n\n"

      << "  char getType() { return MESSAGES::" << toConst(type->name) << "; }\n\n"

      << "  void handle(GenericMessage* msg)\n"
      << "  {\n"
      << "    char type = msg->getMsgType();\n"
      << "    if (type != MESSAGES::" << toConst(type->name)
      << ") assert(\"wrong message type\");\n";

  for (size_t i = 0, n = 0; i < peer->recvMsg.size(); i++)
  {
    nwMessage* msg = peer->recvMsg[i];
    if (!msg || msg->type != type)
      continue;

    if (n == 0)
    {
      out << "    char id = msg->getMsgId();\n\n";

      out << "    if (id == " << toConst(type->name)
          << "::" << toConst(msg->name) << ") handle"
          << msg->name << "(msg);\n";
    }
    else
    {
      out << "    else if (id == " << toConst(type->name)
          << "::" << toConst(msg->name) << ") handle"
          << msg->name << "(msg);\n";
    }

    n++;
  }

  out << "  }\n\n";

  for (size_t i = 0; i < peer->recvMsg.size(); i++)
  {
    nwMessage* msg = peer->recvMsg[i];
    if (!msg || msg->type != type)
      continue;

    out << "  void handle" << msg->name << "(GenericMessage* msg);\n";
  }

  out << "};\n\n";

  out << "#endif // " << toConst(type->name) << "HANDLER_H\n";
}


void nwWriter::writeHandlerImplementation(std::ofstream& out, nwPeer* peer, nwType* type)
{
  writeLicenceHeader(out);

  out << "#include \"client/network/" << toVariable(type->name) << "handler.h\"\n\n";

  out << "#include \"common/eventcs/eventmanager.h\"\n";
  out << "#include \"common/eventcs/entityevent.h\"\n\n";
  out << "#include \"client/pointer/pointer.h\"\n\n";

  if (type->name == "Combat") {
    out << "#include \"client/network/combathandler.h\"\n\n";
  }

  for (size_t i = 0; i < peer->recvMsg.size(); i++)
  {
    nwMessage* msg = peer->recvMsg[i];
    if (!msg || msg->type != type)
      continue;

    out << "void " << type->name << "Handler::" << "handle" << msg->name << "(GenericMessage* msg)\n"
    << "{\n"
    << "  " << msg->name << "Message" << " pmsg;\n"
    << "  pmsg.deserialise(msg->getByteStream());\n\n";
    out << "  using namespace PT::Events;\n";
    out << "  EventManager* evmgr = PointerLibrary::getInstance()->getEventManager();\n";

    typedef std::map<std::string, std::vector<nwParams*> > EventAndParams;
    EventAndParams eventAndParams;

    // Add all the events from the message.
    std::map<std::string, bool>::iterator msgIt;
    for(msgIt = msg->eventNames.begin(); msgIt!=msg->eventNames.end(); ++msgIt)
    {
      eventAndParams[msgIt->first];
    }

    // Add the params to the events.
    for (size_t i = 0; i < msg->params.size(); i++)
    {
      nwParams* param = msg->params[i];
      std::map<std::string, bool>::iterator it;
      for(it = param->eventNames.begin(); it!=param->eventNames.end(); ++it)
      {
        eventAndParams[it->first].push_back(param);
      }
    }

    EventAndParams::iterator it;
    for(it = eventAndParams.begin(); it!=eventAndParams.end(); ++it)
    {
      std::string eventName = it->first;

      if(eventName.empty())
      {
        out << "\n  // @todo Implement me!\n\n";
        continue;
      }

      nwParams* entSpecPar = 0;
      for (size_t i = 0; i < it->second.size(); i++)
      {
        if(it->second[i]->eventNames[eventName])
        {
          entSpecPar = it->second[i];
          break;
        }
      }

      std::string indt = "  ";
      out << indt << "{\n";
      indt = "    ";
      out << indt << "csRef<iEvent> pEvent = evmgr->CreateEvent(";
      if(entSpecPar)
      {
        out << "EntityHelper::MakeEntitySpecific(";
        out << "\"" << eventName << "\"";
        out << ", pmsg." << toGetFunction(entSpecPar->name)<< ")";
      }
      else
        out << "\"" << eventName << "\"";
      out << ", true);\n";

      for (size_t i = 0; i < it->second.size(); i++)
      {
        nwParams* param = it->second[i];
        writeParam(out, param, "pEvent", "", 1);
      }

      out << "\n";
      out << indt << "evmgr->AddEvent(pEvent);\n";
      indt = "  ";
      out << indt << "}\n\n";
    }

    out << "} // end " << "handle" << msg->name << "\n\n";
  }
}

std::string nwWriter::toGetFunction(std::string str, std::string arg)
{
  std::string funct = "get";
  funct += str + "(";
  funct += arg + ")";
  return funct;
}

void nwWriter::writeParam(std::ofstream& out, nwParams* param, const std::string& eventname, const std::string& arg, size_t indent)
{
  std::string indt = "  ";
  for (size_t j = 0; j < indent; j++)
  {
    indt += "  ";
  }

  // results in "paramName".
  std::string paramNameStr = "\"" + toFunction(param->name) + "\"";

  if (param->type == nwParamType::STRING)
  {
    // if its a ptString or uchar*, derefrence it.
    std::string value = "*pmsg.";
    value += toGetFunction(param->name, arg);
    value = value + "?" + value + ":\"\""; // Don't add 0 values!
    out << indt << eventname << "->Add(" << paramNameStr << ", " << value << ");\n";
  }
  else if (param->type == nwParamType::COLOUR24)
  {
    std::string value = "pmsg.";
    value += toGetFunction(param->name, arg) + ".red";
    out << indt << eventname << "->Add(" << paramNameStr << ", " << value << ");\n";
  }
  else if (param->type == nwParamType::VECTOR3F)
  {
    std::string value = "pmsg.";
    value += toGetFunction(param->name, arg);
    if (param->name == "Pos")
      out << indt << "PT::Events::EntityHelper::SetPosition(" << eventname << ", " << value << ");\n";
    else
      out << indt << "PT::Events::EntityHelper::SetVector3(" << eventname << ", " << paramNameStr << ", "<< value << ");\n";
  }
  else if (param->type == nwParamType::LIST)
  {
    std::string listName = "\"" + toFunction(param->name) + "List\"";
    std::string listVarName = toFunction(param->name) + "List";
    out << indt << "csRef<iEvent> "<< listVarName  <<" = evmgr->CreateEvent(" << listName  << ", true);\n"
        << indt << "for (unsigned char i = 0; i < pmsg.get" << param->name << "Count(); i++)\n"
        << indt << "{\n"
        << indt << "  std::stringstream itemName;\n"
        << indt << "  itemName << " << paramNameStr << " << \"_\" << i;\n"
        << indt << "  csRef<iEvent> item = evmgr->CreateEvent(itemName.str().c_str(), true);\n";
    for (size_t j = 0; j < param->params.size(); j++)
    {
      nwParams* listParam = param->params[j];
      writeParam(out, listParam, "item", "i", indent + 1);
    }
    out << indt <<  "  " << listVarName << "->Add(itemName.str().c_str(), item);\n";
    out << indt << "}\n";
    out << indt <<  eventname << "->Add(" << listName << ", "<< listVarName <<");\n";
  }
  else
  {
    std::string value = "pmsg.";
    value += toGetFunction(param->name, arg);
    out << indt << eventname << "->Add(" << paramNameStr << ", " << value << ");\n";
  }
}

void nwWriter::writeServerHandlerImplementation(std::ofstream& out, nwPeer* peer, nwType* type)
{
  writeLicenceHeader(out);

  out << "#include \"server/network/" << toVariable(type->name) << "handler.h\"\n\n";

  out << "#include \"common/event/ieventmanager.h\"\n";
  out << "#include \"common/event/eventdata.h\"\n\n";
  out << "#include \"server/server.h\"\n\n";

  for (size_t i = 0; i < peer->recvMsg.size(); ++i)
  {
    nwMessage* const msg = peer->recvMsg[i];
    if (!msg || msg->type != type)
      continue;

    out << "void " << type->name << "Handler::" << "handle" << msg->name << "(GenericMessage* msg)\n"
      << "{\n"
      << "  " << msg->name << "Message" << " pmsg;\n"
      << "  pmsg.deserialise(msg->getByteStream());\n\n"
      << "  using namespace PT::Event;\n"
      << "  iEventManager* eventManager = Server::getServer()->getEventManager();\n";

    typedef std::map<std::string, std::vector<nwParams*> > EventAndParams;
    EventAndParams eventAndParams;

    // Add all the events from the message.
    std::map<std::string, bool>::iterator msgIt;
    for (msgIt = msg->eventNames.begin(); msgIt != msg->eventNames.end(); ++msgIt)
    {
      eventAndParams[msgIt->first];
    }

    // Add the params to the events.
    for (size_t i = 0; i < msg->params.size(); i++)
    {
      nwParams* param = msg->params[i];
      std::map<std::string, bool>::iterator it;
      for (it = param->eventNames.begin(); it != param->eventNames.end(); ++it)
      {
        eventAndParams[it->first].push_back(param);
      }
    }

    EventAndParams::iterator it;
    for (it = eventAndParams.begin(); it != eventAndParams.end(); ++it)
    {
      const std::string& eventName(it->first);

      if (eventName.empty())
      {
        out << "\n  // @todo Implement me!\n\n";
        continue;
      }

      nwParams* entSpecPar = 0;
      for (size_t i = 0; i < it->second.size(); i++)
      {
        if (it->second[i]->eventNames[eventName])
        {
          entSpecPar = it->second[i];
          break;
        }
      }

      out << "  {\n";
      const std::string indent("    ");
      out << indent << "EventDataPtr event(new EventData(\"" << eventName << "\"";
      if (entSpecPar)
      {
        out << ", pmsg." << toGetFunction(entSpecPar->name);
      }
      out << ");\n";

      for (size_t i = 0; i < it->second.size(); ++i)
      {
        writeServerParam(out, it->second[i], "event", "", 1);
      }

      out << "\n";
      out << indent << "eventManager->Post(event);\n";
      out << "  }\n\n";
    }

    out << "} // end " << "handle" << msg->name << "()\n\n";
  }
}

void nwWriter::writeServerParam(std::ofstream& out, nwParams* param, const std::string& eventname, const std::string& arg, size_t indt)
{
  std::string indent("  ");
  for (size_t j = 0; j < indt; j++)
  {
    indent += "  ";
  }

  const std::string paramNameStr = "\"" + param->name + "\"";

  switch (param->type)
  {
    case nwParamType::LIST:
    {
      const std::string listName = "\"" + param->name + "List\"";
      std::string listVarName = toFunction(param->name) + "List";
      out << indent << "EventDataPtr " << listVarName  << "(new EventData(" << listName << ");\n"
          << indent << "for (unsigned char i = 0; i < pmsg.get" << param->name << "Count(); i++)\n"
          << indent << "{\n"
          << indent << "  std::stringstream itemName;\n"
          << indent << "  itemName << " << paramNameStr << " << \"_\" << i;\n"
          << indent << "  EventDataPtr item(new EventData(itemName.str());\n";
      for (size_t j = 0; j < param->params.size(); ++j)
      {
        nwParams* listParam = param->params[j];
        writeParam(out, listParam, "item", "i", indt + 1);
      }
      out << indent << "  " << listVarName << "->Add<EventDataPtr>(itemName.str(), item);\n";
      out << indent << "}\n";
      out << indent << eventname << "->Add<EventDataPtr>(" << listName << ", " << listVarName << ");\n";
      break;
    }
    default:
    {
      std::string typeName(nwParamTypeName[param->type][0]);
      const std::string value = "pmsg." + toGetFunction(param->name, arg);
      switch (param->type)
      {
        case nwParamType::TEXT:
        {
          typeName = "std::string";
          break;
        }
        case nwParamType::INT8:
        case nwParamType::INT16:
        case nwParamType::INT32:
        {
          typeName = "boost::int32_t";
          break;
        }
        case nwParamType::UINT8:
        case nwParamType::UINT16:
        case nwParamType::UINT32:
        {
          typeName = "boost::uint32_t";
          break;
        }
        default:
        {
          break;
        }
      }

      out << indent << eventname << "->Add<" << typeName << ">(" << paramNameStr << ", " << value << ");\n";
    }
  }
}

